
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Link } from 'react-router-dom';
import { ADVANCED_PENTEST_MYTHOLOGY_DATA } from '../constants';
import { AdvancedMythItem, AdvancedMythPhase, AdvancedMythCodeStep, CustomParam } from '../types';

const CODE_TYPING_CHAR_SPEED_MS = 50; 
const CODE_TYPING_LINE_DELAY_MS = 300; 
const AUTO_ADVANCE_STEP_DELAY_MS = 5000; 


const AdvancedPentestMythologyPage: React.FC = () => {
  const [selectedMyth, setSelectedMyth] = useState<AdvancedMythItem | null>(null);
  const [customParamsValues, setCustomParamsValues] = useState<Record<string, string>>({});
  
  const [currentPhaseIndex, setCurrentPhaseIndex] = useState<number>(0);
  const [currentCodeStepInPhase, setCurrentCodeStepInPhase] = useState<number>(0);
  
  const [codeFrameContent, setCodeFrameContent] = useState<string>('');
  const [isPlaying, setIsPlaying] = useState<boolean>(false);
  const isPlayingRef = useRef(isPlaying); 

  const [isAnimationComplete, setIsAnimationComplete] = useState<boolean>(false);

  const [activeTocPhaseId, setActiveTocPhaseId] = useState<string | null>(null);
  const [activeMobileTab, setActiveMobileTab] = useState<'narrative' | 'code'>('narrative');

  const codeFrameRef = useRef<HTMLDivElement>(null);
  const typingTimeoutRef = useRef<number | null>(null);
  const stepAdvanceTimeoutRef = useRef<number | null>(null);
  
  const isMountedRef = useRef(true);
  const currentCharIndexInCommandRef = useRef(0);
  const isResumingFromPauseRef = useRef(false);


  useEffect(() => {
    isPlayingRef.current = isPlaying;
  }, [isPlaying]);

  useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
      if (typingTimeoutRef.current) clearTimeout(typingTimeoutRef.current);
      if (stepAdvanceTimeoutRef.current) clearTimeout(stepAdvanceTimeoutRef.current);
    };
  }, []);

  const resetAnimationState = useCallback(() => {
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
      typingTimeoutRef.current = null;
    }
    if (stepAdvanceTimeoutRef.current) {
      clearTimeout(stepAdvanceTimeoutRef.current);
      stepAdvanceTimeoutRef.current = null;
    }
    setCodeFrameContent('');
    setCurrentPhaseIndex(0);
    setCurrentCodeStepInPhase(0);
    setIsAnimationComplete(false);
    currentCharIndexInCommandRef.current = 0;
    isResumingFromPauseRef.current = false;
    if (selectedMyth) { 
        setActiveTocPhaseId(selectedMyth.phases[0]?.id || null);
    } else {
        setActiveTocPhaseId(null);
    }
  }, [selectedMyth]);


  useEffect(() => {
    if (selectedMyth) {
      const initialParams: Record<string, string> = {};
      selectedMyth.customParams.forEach(param => {
        initialParams[param.id] = param.defaultValue;
      });
      setCustomParamsValues(initialParams);
      resetAnimationState(); 
      setActiveMobileTab('narrative'); 
    } else {
      resetAnimationState(); 
    }
  }, [selectedMyth, resetAnimationState]);

  const handleCustomParamChange = (paramId: string, value: string) => {
    setCustomParamsValues(prev => ({ ...prev, [paramId]: value }));
  };

  const substituteParams = useCallback((commandTemplate: string): string => {
    let command = commandTemplate;
    Object.entries(customParamsValues).forEach(([key, value]) => {
      command = command.replace(new RegExp(`{{${key}}}`, 'g'), value || '');
    });
    return command;
  }, [customParamsValues]);
  
  const typeCodeStep = (phaseIdx: number, codeStepIdx: number) => {
    if (!selectedMyth || phaseIdx >= selectedMyth.phases.length) {
      setIsAnimationComplete(true);
      setIsPlaying(false);
      return;
    }
    
    const phase = selectedMyth.phases[phaseIdx];
    if (!phase || codeStepIdx >= phase.codeSteps.length) {
      if (phaseIdx + 1 < selectedMyth.phases.length) {
        setCurrentPhaseIndex(phaseIdx + 1);
        setCurrentCodeStepInPhase(0);
        currentCharIndexInCommandRef.current = 0; 
        isResumingFromPauseRef.current = false; 
        setActiveTocPhaseId(selectedMyth.phases[phaseIdx + 1].id);
      } else {
        setIsAnimationComplete(true);
        setIsPlaying(false);
      }
      return;
    }

    const codeStep = phase.codeSteps[codeStepIdx];
    const fullCommand = substituteParams(codeStep.commandTemplate);
    const prompt = `(${phase.title}) user@${customParamsValues.targetUrl || 'target'}:~$ `;

    function typeChar(charIdx: number) {
      if (!isMountedRef.current || !isPlayingRef.current) {
        if (typingTimeoutRef.current) clearTimeout(typingTimeoutRef.current);
        typingTimeoutRef.current = null;
        return;
      }
      if (charIdx < fullCommand.length) {
        setCodeFrameContent(prev => prev + fullCommand[charIdx]);
        currentCharIndexInCommandRef.current = charIdx + 1;
        typingTimeoutRef.current = window.setTimeout(() => typeChar(charIdx + 1), CODE_TYPING_CHAR_SPEED_MS);
      } else {
        currentCharIndexInCommandRef.current = 0; 
        isResumingFromPauseRef.current = false; 

        let output = `\n${codeStep.mockOutput || 'Command executed.'}`;
        if (codeStep.explanation) {
          const explanationLines = codeStep.explanation.split('\n');
          explanationLines.forEach(line => { output += `\n// ${line}`; });
        }
        output += '\n\n'; 
        setCodeFrameContent(prev => prev + output);

        stepAdvanceTimeoutRef.current = window.setTimeout(() => {
            if(isMountedRef.current && isPlayingRef.current) {
                 setCurrentCodeStepInPhase(prevStepIdx => prevStepIdx + 1); 
            } else {
                if(stepAdvanceTimeoutRef.current) { 
                    clearTimeout(stepAdvanceTimeoutRef.current);
                    stepAdvanceTimeoutRef.current = null;
                }
            }
        }, AUTO_ADVANCE_STEP_DELAY_MS);
      }
    }

    if (isResumingFromPauseRef.current) {
        isResumingFromPauseRef.current = false; 

        if (currentCharIndexInCommandRef.current > 0 && currentCharIndexInCommandRef.current < fullCommand.length) {
            typingTimeoutRef.current = window.setTimeout(() => {
                if (isMountedRef.current && isPlayingRef.current) {
                    typeChar(currentCharIndexInCommandRef.current);
                }
            }, CODE_TYPING_LINE_DELAY_MS);
            return; 
        } else if (currentCharIndexInCommandRef.current === 0) {
             const contentEndsWithPrompt = codeFrameContent.trimEnd().endsWith(prompt.trimEnd());
             const contentEndsWithOutput = codeFrameContent.endsWith('\n\n');

             if (contentEndsWithPrompt && !contentEndsWithOutput) { // Prompt is there, command not typed
                typingTimeoutRef.current = window.setTimeout(() => {
                    if (isMountedRef.current && isPlayingRef.current) {
                        typeChar(0); // Start typing command
                    }
                }, CODE_TYPING_LINE_DELAY_MS);
                return;
             } else if (contentEndsWithOutput || codeFrameContent.trim() === '') { // Output shown (or very start), waiting for auto-advance or was very start of entire sequence
                stepAdvanceTimeoutRef.current = window.setTimeout(() => {
                    if (isMountedRef.current && isPlayingRef.current) {
                        setCurrentCodeStepInPhase(prevStepIdx => prevStepIdx + 1);
                    }
                }, AUTO_ADVANCE_STEP_DELAY_MS);
                return;
             }
        }
    }
    
    currentCharIndexInCommandRef.current = 0; 

    setCodeFrameContent(prev => {
        const trimmedPrev = prev.trimEnd();
        if (trimmedPrev === '' || trimmedPrev.endsWith('\n\n')) {
            return prev + prompt;
        }
        const lines = trimmedPrev.split('\n');
        if (lines.length > 0 && lines[lines.length - 1].startsWith(prompt.substring(0, prompt.indexOf(':~$') + 3))) {
            if (lines[lines.length -1].trimEnd() === prompt.trimEnd()) return prev; // Prompt already fully there
        }
        return prev + '\n' + prompt;
    });

    typingTimeoutRef.current = window.setTimeout(() => {
        if (isMountedRef.current && isPlayingRef.current) {
            typeChar(0); 
        }
    }, CODE_TYPING_LINE_DELAY_MS);
  };


  useEffect(() => {
    if (isPlaying && selectedMyth && !isAnimationComplete) {
       if (typingTimeoutRef.current) { 
           clearTimeout(typingTimeoutRef.current);
           typingTimeoutRef.current = null;
       }
       if (stepAdvanceTimeoutRef.current) { 
           clearTimeout(stepAdvanceTimeoutRef.current);
           stepAdvanceTimeoutRef.current = null;
       }
       typeCodeStep(currentPhaseIndex, currentCodeStepInPhase);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps 
  }, [isPlaying, selectedMyth, currentPhaseIndex, currentCodeStepInPhase, isAnimationComplete, customParamsValues, substituteParams]); 

  const handlePlayPause = () => {
    if (!selectedMyth) return;

    if (isPlayingRef.current) { // Means "Pause" was clicked
        isResumingFromPauseRef.current = true; // Set flag for next play FIRST
        if (typingTimeoutRef.current) { // Clear timeouts NEXT
            clearTimeout(typingTimeoutRef.current);
            typingTimeoutRef.current = null;
        }
        if (stepAdvanceTimeoutRef.current) {
            clearTimeout(stepAdvanceTimeoutRef.current);
            stepAdvanceTimeoutRef.current = null;
        }
        setIsPlaying(false); // Set state LAST
    } else { // Means "Play" or "Resume" or "Replay" was clicked
        if (isAnimationComplete) { 
            resetAnimationState(); 
        }
        setIsPlaying(true); 
    }
  };
  
  const handleResetQuest = () => {
    if (!selectedMyth) return;
    setIsPlaying(false); 
    resetAnimationState(); 
  };

  const handleTocClick = (phaseId: string) => {
    if (!selectedMyth) return;
    const phaseIdx = selectedMyth.phases.findIndex(p => p.id === phaseId);
    if (phaseIdx !== -1) {
      setIsPlaying(false); 
      if (typingTimeoutRef.current) {
          clearTimeout(typingTimeoutRef.current);
          typingTimeoutRef.current = null;
      }
      if (stepAdvanceTimeoutRef.current) {
          clearTimeout(stepAdvanceTimeoutRef.current);
          stepAdvanceTimeoutRef.current = null;
      }

      setCurrentPhaseIndex(phaseIdx);
      setCurrentCodeStepInPhase(0);
      setActiveTocPhaseId(phaseId);
      setIsAnimationComplete(false); 
      currentCharIndexInCommandRef.current = 0; 
      isResumingFromPauseRef.current = false;   
      setActiveMobileTab('code'); 

      let tempCodeContent = '';
      for (let i = 0; i < phaseIdx; i++) {
        selectedMyth.phases[i].codeSteps.forEach(cs => {
          const promptText = `(${selectedMyth.phases[i].title}) user@${customParamsValues.targetUrl || 'target'}:~$ `;
          tempCodeContent += promptText + substituteParams(cs.commandTemplate) + '\n';
          tempCodeContent += (cs.mockOutput || 'Command executed.');
           if (cs.explanation) {
            const explanationLines = cs.explanation.split('\n');
            explanationLines.forEach(line => {
                tempCodeContent += `\n// ${line}`;
            });
           }
          tempCodeContent += '\n\n';
        });
      }
      setCodeFrameContent(tempCodeContent);
    }
  };

   useEffect(() => {
    if (codeFrameRef.current) {
      codeFrameRef.current.scrollTop = codeFrameRef.current.scrollHeight;
    }
  }, [codeFrameContent]);

  if (!ADVANCED_PENTEST_MYTHOLOGY_DATA || ADVANCED_PENTEST_MYTHOLOGY_DATA.length === 0) {
    return <div className="text-center py-40 text-xl">Advanced Mythology data is currently unavailable. Please check back later.</div>;
  }

  return (
    <div className="bg-transparent min-h-screen py-24 px-4 sm:px-6 lg:px-8 text-text-off-white">
      <div className="container mx-auto">
        <header className="text-center mb-12 pt-10 relative">
            <h1 className="text-4xl sm:text-5xl font-headings font-bold text-accent-blue transition-all duration-300 hover-neon-glow-blue relative z-10">
                <i className="fas fa-shield-alt mr-3"></i>Advanced Pentest Mythology
            </h1>
            <p className="text-lg text-gray-400 mt-2 relative z-10">Embark on an interactive mythic journey through modern web vulnerabilities.</p>
        </header>

        {!selectedMyth ? (
          <>
            <p className="text-center text-xl mb-8 text-accent-green">Select a Myth to Begin Your Quest:</p>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 pb-4">
              {ADVANCED_PENTEST_MYTHOLOGY_DATA.map(myth => (
                <button
                  key={myth.id}
                  onClick={() => setSelectedMyth(myth)}
                  className="w-full bg-base-light-dark p-6 rounded-lg shadow-lg hover:shadow-glow-purple transform hover:-translate-y-1 transition-all duration-300 text-left border border-gray-700 hover:border-accent-purple flex flex-col justify-between min-h-[200px] sm:min-h-[220px]"
                >
                  <div>
                    <div className="flex items-center mb-3">
                      <i className={`${myth.iconClass} text-3xl text-accent-purple mr-3`}></i>
                      <h2 className="text-xl font-headings font-semibold text-white">{myth.title}</h2>
                    </div>
                    <p className="text-sm text-gray-300 line-clamp-3 mb-2 flex-grow">{myth.legend}</p>
                  </div>
                  <span className="text-xs text-accent-blue font-semibold mt-auto self-start block pt-2">Begin Quest &rarr;</span>
                </button>
              ))}
            </div>
          </>
        ) : (
          <div>
            <button 
                onClick={() => { setIsPlaying(false); setSelectedMyth(null); resetAnimationState();}} 
                className="mb-8 text-accent-blue hover:text-accent-green transition-colors hover-neon-glow-blue">
                <i className="fas fa-arrow-left mr-2"></i> Back to Myth Selection
            </button>

            <div className="sm:hidden mb-4">
                <div className="flex border-b border-gray-700">
                    <button 
                        onClick={() => setActiveMobileTab('narrative')}
                        className={`flex-1 py-2 px-1 text-center font-headings text-sm ${activeMobileTab === 'narrative' ? 'text-accent-green border-b-2 border-accent-green' : 'text-gray-400 hover:text-accent-green'}`}
                    >Narrative & TOC</button>
                    <button 
                        onClick={() => setActiveMobileTab('code')}
                        className={`flex-1 py-2 px-1 text-center font-headings text-sm ${activeMobileTab === 'code' ? 'text-accent-green border-b-2 border-accent-green' : 'text-gray-400 hover:text-accent-green'}`}
                    >Code Simulation</button>
                </div>
            </div>

            <div className="grid lg:grid-cols-3 gap-8">
              <div className={`lg:col-span-1 ${activeMobileTab === 'narrative' ? 'block' : 'hidden sm:block'}`}>
                <div className="bg-base-light-dark p-6 rounded-lg shadow-md border border-gray-700 mb-6">
                  <h3 className="text-2xl font-headings font-bold text-accent-purple mb-3 flex items-center">
                    <i className={`${selectedMyth.iconClass} mr-3`}></i>{selectedMyth.title}
                  </h3>
                  <p className="text-sm text-gray-300 italic mb-2 leading-relaxed">{selectedMyth.narrativeIntro}</p>
                  <p className="text-sm text-accent-green leading-relaxed">{selectedMyth.vulnerabilityAnalogy}</p>
                </div>
                
                <div className="sticky top-24 methodology-toc-sticky custom-scrollbar overflow-y-auto p-1 max-h-[calc(100vh-12rem)] lg:max-h-[calc(100vh-10rem)]">
                  <h4 className="text-lg font-headings text-accent-green mb-3">Quest Phases (TOC):</h4>
                  <ul className="space-y-1">
                    {selectedMyth.phases.map(phase => (
                      <li key={phase.id}>
                        <button
                          onClick={() => handleTocClick(phase.id)}
                          className={`block w-full text-left py-1.5 px-3 rounded-md border-l-2 transition-all duration-200 text-sm
                            ${activeTocPhaseId === phase.id ? 'bg-accent-green/20 text-accent-green font-semibold border-accent-green' : 'text-gray-400 border-gray-700 hover:bg-gray-700 hover:text-white hover:border-accent-blue'}`}
                        >
                          {phase.title}
                           {phase.description && <span className="block text-xs text-gray-500 mt-0.5 line-clamp-1">{phase.description}</span>}
                        </button>
                      </li>
                    ))}
                  </ul>
                </div>
              </div>

              <div className={`lg:col-span-2 ${activeMobileTab === 'code' ? 'block' : 'hidden sm:block'}`}>
                <h3 className="text-2xl font-headings text-accent-blue mb-3">Interactive Code Console</h3>
                
                <div className="mb-4 p-4 bg-gray-800 rounded-md border border-gray-700">
                  <h4 className="text-md font-semibold text-accent-purple mb-2">Customize Parameters:</h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    {selectedMyth.customParams.map(param => (
                      <div key={param.id}>
                        <label htmlFor={param.id} className="text-xs text-gray-400 block mb-0.5">{param.label}</label>
                        {param.type === 'select' ? (
                            <select 
                                id={param.id} 
                                value={customParamsValues[param.id] || param.defaultValue}
                                onChange={(e) => handleCustomParamChange(param.id, e.target.value)}
                                className="w-full bg-gray-900 border border-gray-600 rounded py-1 px-2 text-sm text-text-off-white focus:ring-accent-blue focus:border-accent-blue"
                            >
                                {param.options?.map(opt => <option key={opt} value={opt}>{opt}</option>)}
                            </select>
                        ) : (
                            <input
                              type={param.type || 'text'}
                              id={param.id}
                              value={customParamsValues[param.id] || param.defaultValue}
                              onChange={(e) => handleCustomParamChange(param.id, e.target.value)}
                              placeholder={param.placeholder}
                              className="w-full bg-gray-900 border border-gray-600 rounded py-1 px-2 text-sm text-text-off-white focus:ring-accent-blue focus:border-accent-blue"
                            />
                        )}
                      </div>
                    ))}
                  </div>
                </div>

                <div 
                    ref={codeFrameRef}
                    className="myth-code-frame bg-[#0e0e0e] text-[#00FFAA] font-['Source_Code_Pro',_monospace] p-4 border-2 border-[#00E5FF] rounded-md h-96 overflow-y-auto whitespace-pre-wrap text-sm leading-relaxed custom-scrollbar"
                    aria-live="polite"
                    role="log"
                >
                  {codeFrameContent}
                  {isPlaying && !isAnimationComplete && <span className="typed-cursor-blink bg-[#00FFAA]"></span>}
                </div>

                <div className="mt-4 flex flex-wrap gap-3 items-center">
                  <button onClick={handlePlayPause} className="bg-accent-green text-base-dark font-semibold py-2 px-4 rounded hover:bg-opacity-80 transition-colors hover-neon-glow-green">
                    <i className={`fas ${isPlaying ? 'fa-pause' : 'fa-play'} mr-2`}></i>
                    {isAnimationComplete ? 'Replay Quest' : isPlaying ? 'Pause' : 'Play Quest'}
                  </button>
                  <button onClick={handleResetQuest} className="bg-accent-red text-base-dark font-semibold py-2 px-4 rounded hover:bg-opacity-80 transition-colors hover-neon-glow-red">
                    <i className="fas fa-undo mr-2"></i>Reset
                  </button>
                </div>
                
                <div className="mt-4 p-3 bg-gray-800 rounded-md border border-gray-700">
                    <h4 className="text-sm font-semibold text-accent-purple mb-1">
                        Current Phase: <span className="text-accent-green">{selectedMyth.phases[currentPhaseIndex]?.title || 'N/A'}</span>
                    </h4>
                    <p className="text-xs text-gray-400">
                        {selectedMyth.phases[currentPhaseIndex]?.description}
                    </p>
                    <h5 className="text-xs font-semibold text-accent-purple mt-2 mb-1">
                        Current Action: <span className="text-gray-300">{selectedMyth.phases[currentPhaseIndex]?.codeSteps[currentCodeStepInPhase]?.title || (isAnimationComplete? 'Quest Complete' : 'Awaiting action...')}</span>
                    </h5>
                    <pre className="text-xs text-gray-400 whitespace-pre-wrap max-h-24 overflow-y-auto custom-scrollbar mt-1">
                        { isPlaying && !isAnimationComplete ? "// Simulating command execution..." : 
                          selectedMyth.phases[currentPhaseIndex]?.codeSteps[currentCodeStepInPhase-1]?.mockOutput || (codeFrameContent ? "// Last command output displayed in console." : "// Console output will appear here.")}
                    </pre>
                </div>
                 <div className="mt-3 p-3 bg-gray-800 rounded-md border border-gray-700 text-xs text-gray-400">
                  <p>Progress: Phase {Math.min(currentPhaseIndex + 1, selectedMyth.phases.length)} of {selectedMyth.phases.length}. Step {currentCodeStepInPhase} of {selectedMyth.phases[currentPhaseIndex]?.codeSteps.length || (isAnimationComplete ? selectedMyth.phases[selectedMyth.phases.length-1]?.codeSteps.length : 0)}</p>
                  <p>{isAnimationComplete ? "Quest Complete!" : isPlaying ? "Executing steps..." : "Paused."}</p>
                </div>
              </div>
            </div>

            <div className="mt-12 pt-8 border-t border-gray-700">
              <h3 className="text-2xl font-headings text-accent-purple mb-4">Treasure Trove (Resources)</h3>
              <ul className="space-y-3">
                {selectedMyth.resources.map(resource => (
                  <li key={resource.name}>
                    <a href={resource.url} target="_blank" rel="noopener noreferrer" className="text-gray-300 hover:text-accent-purple hover:underline transition-colors group">
                      {resource.icon ? <span className="mr-2 text-accent-purple group-hover:text-white text-lg"><i className={resource.icon} aria-hidden="true"></i></span> : <i className="fas fa-book-reader mr-2 text-accent-purple group-hover:text-white" aria-hidden="true"></i>}
                      {resource.name}
                      <i className="fas fa-external-link-alt ml-2 text-xs opacity-70"></i>
                    </a>
                  </li>
                ))}
              </ul>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default AdvancedPentestMythologyPage;
